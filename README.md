# 이지은 202330123

## 5월 31일 강의

### jcomponent 기능
- 스윙 컴포넌트는 모두 상속 받는 슈퍼 클래스, 추상 클래스
- 스윙 컴포넌ㅌ트들이 상속받는 공통 메소드와 상수 구현

### JLabel 문자열이나 이미지 레이블 생성
- 이미지 레이블 생성
- 이미지 파일로 부터 이미지를 읽기 위해  Imagelcon 클래스, 사용
- 다룰수 잇는 이미지:png gif jpg

### 이미지 버튼 만들기
- normallcon
   - 버튼의 보통 상태 때 출력되는 이미지
- rolloverlcon
   - 버튼에 마우스가 올라갈 때 출력 되는 이미지
- pressedicon
   - 버튼을 누른 상태로 출력되는 이미지
   - 이미지 설정 메소드'JButton'의 'setPressedIcon(pressedIcon)'을 사용

### item 이벤트 
  - 체크박스의 선택 상태에 변화가 생길 때 발생하는 이벤트 
     - 사용자가 마우스나 키보드로 체크박스를 선택/해제할 때
     - 프로그램에서체크박스를 선택/헤제하여 체크 상태에 변화가 생길 때
  - 이벤트가 발생하면 itemEvent 객체생성
  - itenListener 리스너의 추상 메소드

### JBadiobutton
  버튼 그룹을 형성하고 그룹에 속한 버튼중 하나만 선택되는 라디오 버튼

   - 생성 과정
   1. 버튼 그룹 객체 생성
   2. 라디오 버튼 생성
   3. 라디오 버튼 을 버튼 그룹에 삽입
   4. 라디오 버튼 을 컨테이너에 삽입
      

### JTextField
- 한줄의 문자열을 입력 받는 창
   - 텍스트 입력 도중 'Enter'키가 입력되면  입력되면 Action 이벤트가 발생
   - 입력 가능한 문자 개수와 입력 창의 크기는 서로 다를 수 있음
### JList 'E'
하나 이상의 아이템을 보여주고 사용자가 아이템을 선택할수 있도록 함  

## 5월 24일 강의

이벤트 기반 프로그래밍

- 이벤트의 발생에 의해 프로그램 흐름이 결정되는 방식
- 반대되는 개념: 배치 실행
- 이벤트 종류(사용자의 입력, 센서로부터의 입력, 네트워크로부터 데이터 송수신, 다른 응용프로그램이나 다른 스레드로부터의 메시지)
  
### 이벤트 기반 응용 프로그램의 구조

   각 이벤트마다 처리하는 리스너 코드 보유
  
### GUI 응용프로그램은 이벤트 기반 프로그래밍으로 작성됨

- GUI 라이브러리 종류(C++의 MFC, C# GUI, Visual Basic, C Window, Android 등)
- 자바의 AWT와 Swing
  
### 이벤트가 처리되는 과정

- 이벤트 발생
- 이벤트 객체 생성
- 응용프로그램에 작성된 이벤트 리스너 찾기
- 이벤트 리스너 실행(리스너에 이벤트 객체 전달, 리스너 코드 실행)

### 이벤트 객체

- 발생한 이벤트에 관한 정보를 가진 객체
- 이벤트 리스너에 전달됨

### 이벤트 객체가 포함하는 정보

- 이벤트 종류와 이벤트 소스
- 이벤트가 발상한 화면 좌표 및 컴포넌트 내 좌표
- 이벤트가 발생한 버튼이나 메뉴 아이템의 문자열
- 클릭된 마우스 버튼 번호 및 마우스의 클릭 횟수
- 키의 코드 값과 문자 값
- 체크박스, 라디오버튼 등과 같은 컴포넌트에 이벤트가 발생하였다면 체크 상태
  
### 이벤트 소스를 알아 내는 메소드
Object getSource()

- 발생한 이벤트의 소스 컴포넌트 리턴
- Object 타입으로 리턴하므로 캐스팅하여 사용
- 모든 이벤트 객체에 대해 적용
  
### 이벤트 리스너

- 이벤트를 처리하는 자바 프로그램 코드, 클래스로 작성
자바는 다양한리스너 인터페이스 제공
사용자의 이벤트 리스너 작성

- 자바의 리스너 인터페이스를 상속받아 구현
- 리스너 인터페이스의 모든 추상 메소드 구현
//

### 이벤트 리스너 작성 과정 사례 
1. 이벤트와 이벤트 리스너 선택
   - 버튼클릭을 처리하고자 하는
2. 이벤트 리스너 클래스 작성:ActionListener 인터페이스 구현
3. 이벤트 리스너 등록
   - 이벤트를 받아 퍼리 하고자 하는 컴포넌트에 이벤트 리스너 등록

### 이벤트 리스너 작성 방법
 1. 독립 클래스로 작성
   - 이벤트 리스너를 완전히 클래스로 작성
   - 이벤트 리스너를 여러곳에서 사용할때 적합
 2. 내부 클래스로 작성
   - 클래스안에 맴버처럼 클래스 작성
   - 이벤트 리스너를 특정 클래스에서만 사용할때 적합
 3. 익명클래스로 작성
   - 클래스 이름 없이 간단히 리스너 작성
   - 클래스 조차 만들 필요 없이 리스너 코드가 간단한 경우에 적합

### 익명 클래스로 이벤트 리스너 작성
 - 익명 클래스 :이름없는 클래스
   - 클래스 선언+인스턴트 생성 을 한번에 달성
   - 간단한 리스너의 경우 익명 클래스 사용 추천(메소드의 개수가 1,2개인 리스너(ActionListener,ItemListener)에 대해 주로 사용)

### 어댑터 클래스 
 - 이벤트 리스너 구현에 따른 부담
    - 리스너의 추상 메소드를 모두 구현해야 하는 부담
 - 어댑터 클래스
    - 라이너의 모든 메소드를 

### key이벤트와 포커스 
- 키 입력시 다음 세 경우 각각 키 이벤트 발생
   - 키를 누르는 순간
   - 누른 키를 떼는 순간
   - 누른 키를 때는 순간(unicode 키의 경우에만)

- 키이벤트 받을수 있는 조건
   - 모든 컴포넌트
   - 현재 포커스를 가진 컴포넌트가 키 이벤트 독점

- 포커스
   - 컴포넌트나 응용 프로그램이 키 이ㅔㄴ트를 독점하는 권한

### 유니코드키의 특징
- 국제 산업 표준
- 전 세게의 문자를 컴푸터에서 일관 되게 표현하기 위한 코드 체계 
- 문자들에 대해서만 키 코드 값 정의
- 문자가 아닌 키 경우에는 표준화된 키 코드 값없음

유니 코드 키가 입력 되는 경우
   - keyPressed()

- keyEvent 객체
   -  입력된 키 정보를 가진 이벤트 객체
- keyEvent 객체의 메소드로 입력된 키 판별

- 객채의 매소드로 입력된 키 판별
   - char keyEventgetKeyChar()
      - 키의 유니토드 문자값 리턴


## 5월 17일 강의

### 대표 배치 관리자
- FlowLayout 배치관리자: 
   컴포넌트가 삽입 되는 순서대로 왼쪽에서 오른쪽으로 배치
- BorderLayout 배치관리자:
  컨테이너의 공간을 동 서 남북 중앙의 5개 영역으로 나눔
- GridLayout 배치관리자:
컨테이너를 프로그램에서 설정한 동일한 크기의 2차원 격자로 나눔
- CardLayout 배치관리자:
컨테이너 공간에서 카드를 쌓아 놓은 듯이 컴포넌트를 포개어 배치

### 컨테이너에 새로운 배치관리자 설정
- setLayout(layoutManager lm)메소드 호출
- lm을 새로운 배치 관리자로 설정

배치방법:컴포넌트를 컨테이너 내에 왼쪽에서 오른쪽으로 배치

### flowlayout의 생성자
 - flowlayout()<br>
 - flowlayout(int align, int hgap, int vGap)<br>
 - align:컴포넌트를 정렬하는 방법 지정<br>
 - hGap:좌우 두 컴포넌트 사이의 수평 간격 픽셀 단위(디폴트:0)<br>
 - vGap:상하 컴포넌트 사이의 //배열<br>

 ### borderlayout의 생성자
   borderlayout(int hGap, int vGap)<br>
   hGap:좌우 두 컴포넌트 사이의 수평 간격, 픽셀 단위(디폴트:0)<br>
   vGap:상하 두 컴포넌트 사이의 수직 간격, 픽셀 단위(디폴트:0)<br>

add() 메소드<br>
 - void add(Component comp,int index)<br>
 - comp:컴포넌트 index 위치에 삽입한다.<br>
 - index:컴포넌트의 위치<br>
 < 동: BorderLavout.EAST 서:BorderLavout.WEST 남: BorderLavout.SOUTH 북:BorderLavout.NORTH 중앙:BorderLavout.CENTER >

### GridLayout 생성자
 GridLayout (int rows, int cols) <br>
 GridLayout (int rows, int cols, int hGap, intvGap)<br>
 rows: 격자의 행수 (디폴트:1)<br>
 cols: 격자의 열수 (디폴트:1)<br>
 hGap:좌우 두 컴포넌트 사이의 수평 간격, 픽셀 단위(디폴트:0)<br>
 vGap:상하 두 컴포넌트 사이의 수직 간격, 픽셀 단위(디폴트:0)<br>
 rows x cols 만큼의 셀을 가진 격자로 컨테이너 공간을 분할, 배치<br>

 - 배치관리자 없는 컨테이너 필요한 경우<br>
 응용 프로그램에서 직접 컴포넌트의 크기와 위치를 결정하고자 하는 경우 
 1. 컴포넌트의 크기나 위치를 개발자 임의로 결정하고자 하는경우
 2. 게임 프로그램과 같이 시간이나 마우스 키보드의 입력에 따라 컴포넌트들의 위치와 크기가 수시로 변하는 경우
 3. 여러 컴포넌트들이 서로 겹쳐 출력하고 있음

- 배치관리자가 없는 컨테이너에 컴포넌트를 삽입할때 
프로그램에서 컴포넌트의 절대 크기와 위치 설정<br>
컴포넌트들이 서로 겹치게 할 수 있음<br>


## 5월 3일 강의
컬렉션: 요소 라고 불리는 가변 개수의 객체들의 저장소 , 고정 크기의 배열을 다루는 어려움 해소, 다양한 객체들의 삽이부 삭제,검색 등의 관리 용이

컬렉션 제네릭 기법으로 구현
제네릭: 특정타입만 다루지 않고, 여러 종류의 타입으로 변신할 수 있도록 클래스나 메소드를 일반화 시키는 기법
클래스나 인터페이스 이름에 E,K,V 등 타입 매개변수 포함

백터 E의 특성
 E에 사용할 요소의 특정 타입으로 구체화
   배열의 길이 제한 극복
 배열을 가변 크기로 다룰수 있게 하는 컨테이너
 요소 객체들을 삽입 삭제 검색 하는 컨테이너
 vector에 삽입 가능한 것
 vector에 객체 삽입
 vector에서 객체 삭제

ArrayList E
 가변 크기 배열을 구현한 클래스
   E에 요소로 사용할 특정 타입으로 구체화
 벡터와 거의 동일
   요소 삽입 삭제 검색 등 벡터기능과 거의 동일
   벡터와 달리 동기화 기능 없음
  
iterator E 인터페이스
  리스트 구조의 컬렉션에서 요소의 순차 검색을 위한 인터페이스

iterator 객체 얻어내기 
  컬렉션의 iterator()메소드 호출
    해당 컬랙션을 순차 검색할수 있는 iterator 객체 리턴
hashmap k,v
 키와 값의 쌍으로 구성되는 요소를 다루는 컬렉션
   k: 키로 사용할 요소의 타입
   v: 값으로 사용할 요소의 타입
   키와 값이 한 쌍으로 삽입
   값을 검색하기 위해서는 반드시 키 이용
 삽입 및 검색이 빠른 특징
   요소 삽입 :put()메소드

gul응용 프로 그램
 사용자가 편히하게 입출력 할수 있도록 그래픽으로 화면을 구성하고 마우스나 키보드로 입력 받을 수 있도록 지원하는 사용자 인터페이스

awt 와swing 패키지
 awt 자바가 처음 나왔을때 부터 배포된gul 패키지 최근엔 거의 사용안함
 swing awt기술을 기반 으로 작성된 자바 라이브러리

컨테이너:다른 컴포넌트를 포함핧수 있는 gul컴포넌트
컴포넌트: 컨테이너에 포함되어야 화면에 출력 될수 있는 gul객체



## 4월 19일 강의

추상클래스 상속: 추상클래스 상속 받으면 추상 클래스가 됨(서브 클래스도 abstract로 선언 해야함)
추상 클래스 구현: 서브 클래스에서 슈퍼 클래스의 추상 메소드 구현(오버라이딩),추상 클래스를 구현한 서브 클래스는 추상 클래스 아님
추상클래스의 목적: 상속을 위한 슈퍼 클래스로 활용하는 것, 서브 클래스에서 추상 메소드 구현, 다형성 실현

자바의 인터페이스: 클래스가 구현해야 할 메소드들이 선언되는 추상형(interface로 선언),인터페이스 상속해서 확장된 인터페이스 작성 가능

인터페이스 구성요소
 상수: public만 허용,추상 메소드 ,default 메소드,private 메소드, static

6장
패키지: 서로 관련된 클래스와 인터 페이스를 컴파일한 클래스 파일들을 묶어 놓은 디렉터리,하나의 응용 프로 그램은 한갱 이상의 패키지로 작성(jdk)

모듈:여러 패키지와 이미지 등의 자원을 모아 놓은 컨테이너(하나의 모듛을 하나의.jmod파일의 저장) 
모듈화의 목적:응용 프로그램이 실행할때 꼭 필요한 모듈들로만 실행환경 구축 (메모리 자원이 열악한 작은 소형기기에 꼭 필요한 모듈로 구성된 작은 크기의실행 이미지를 만들기 위함)
모듈의 현실: 현실적으로 모듈로 나누어 자바 프로그램을 작성할 필요없음
자바 jdk에 제공되는 모듈 파일들:jmods( jmod)
다른 패키지에 작성도니 클래스 사용:import를 이용

*:와일드(전부)

페키지 만드는 방법 :java project>src>+>package
object 클래스 :모든 자바클래스는 반드시object를 상속 받도록 자동 컴파일
toString()메소드 :toString()을 오버라이딩 하여 자신만의 문자열 리턴 가능

boolean equals(object obj)
  두 객페의 내용물 비교
  객체의 내용물을 비교하기 위해 클래스의 멤버로 작성

Wrapper클래스: 자바의 기본 타입을 클래스 화한 8개클래스를 통칭

박싱: 기본 타입의 값을 Wrapper객체로 변환 하는것
언박싱: Wrapper객체에 들어있는 기본 타입의 값을 빼내는것
String:여러개의 문자열


## 4월 12일 강의

static 
객체랑 상관없이 사용가능(non-static맴버 활용불가,non-static메소드는 static 맴버 사용 가능)

final 상수 필드는 선언 시에 초기값을 지정하여야 한다 (변경할수 없음)

5장 
상속: 자식이 부모유전자 물려받는것과 같음
상속 선언:extends 키워드로 선언
부모 클래스: 슈퍼클래스
자식 클래스: 서브클래스

슈퍼 클래스의 private 멤버: 서브 클래스에서 접근 할수 없음
슈퍼 클래스의 디폴트 멤버: 서브클래스가 동일한 패키지에 있을때 접근 가능

protected 멤버에 대한 접근: 같은 패키지의 모든 클래스에게 허용 상속되는서브 클래스(같은 패키지든 다른 패키지든 상관없음)허용

서브 클래스의 객체가 생성될때:슈퍼 클래스 생성자와 서브 클래스 생성자 모두 실행,서브클래스의 생성자 먼저 호출 서브클래스의 생성자는 실행 전 슈퍼클래스 생성자 실행

슈퍼 클래스와 서브 클래스 각각 여러개의 생성자 작성 가능
서브 클래스의 객체가 생성 될때: 슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행
서브 클래스의 생성자와 슈퍼 클래스의 생성자가 곂치는 경우
 1. 개발자의 명시적 선택
 2. 컴파일러가 기본 생성자 선택

업캐스팅
 서브 클래스의  레퍼런스를 슈퍼 클래스 레퍼런스에 대입
 슈퍼 클래스 레퍼런스로 서브 클래스(객채를 가리키게 되는 현상)

다운캐스팅
 슈퍼 클래스 레퍼런스를 서브 클래스 래퍼런스에 대입
 업케스팅된 것을 다시 원래대로 되돌리는 것
 반드시 명시적 타입 변환 지정

intanceof 연산자: 레퍼런스가 가리키는 객체연산 타입

메소드 오버라이딩 
 서브클래스에서 슈퍼를래스의 메소드중에 작성
 슈퍼클래스의 메소드 무력화 항상 서브 클래스 에서 오버라이딩 당한 메소드가 실헹되도록 보장함
 "메소드 무시하기"로 변역되기도 함

오버라이딩 조건: 슈퍼클래스 메소드의 원형 (메소드 이름 인자타입 및 개수,리턴 타입) 동일하게 작성

super :슈퍼클래스의 멤버를 접근할 때 사용되는 레퍼런스

추상 메소드 :abutract로 선언된 메소드, 메소드의 코드는 없고 원형만 선언
추상 클래스 :추상메소드를 가지며 abutract로 선언된클래스,추상 메소드 없이, abstract로 선언한 클래스(완전한 클래스가 아니라서 객체 생성 불가)


## 4월 5일 강의
배열 리턴: 레퍼런스만 리턴(배열 전체가 리턴 되는것이 아님)

메소드의 리턴 타입
  리턴하는 배열의 타입과 리턴 받는 배열 타입 일치
  리턴 타입에 배열의 크기를 지정하지 않음

예외: 실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황 발생 

실세계 객체의 특징: 객체마다 고유한 특성과 행동을 가짐

캡슐화: 객체를 캡슐로 싸서 내부를 볼수 없게 함(외부의 접근으로 부터 객체 보호)

상속: 상위 개체의 속성이 하위개페에 물려짐, 하위 개체가 상위 개체의 속성을 모두 가지는 관계
자바 상속:상위 클래스의 맴버를 하위 클래스가 물려받음
상위 클래스: 수퍼 클래스 / 하위 클래스: 서브 클래스 수퍼 클래스 코드 재사용 새로운 특성 추가 기능

다형성: 같은 이름의 매소드가 클래스 혹은 객체에 따라 다르게 구현되는 것
  메소드의 오버로딩:한 클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드
  메소드의 오버라이딩 다르게 구현: 슈퍼 클래스와 메소드를 동일한 이름으로 서브 클래스마다 다르게 구현

소프트웨어의 생산성 향상
  컴퓨터 산업 발전에 따라 소프트웨어의 생명주기 단축
  객체지향 언어 
실세계 대한 쉬운 모델링
  초기 프로그래밍:계산절차가 중요

절차지향 프로그래밍: 작업 순서를 표현하는 컴퓨터 프로그램의 집합
객체지향 프로그래밍: 컴퓨터가 수행하는 작업을 객체들간의 상호 작용으로 표현

클래스: 객체의 속성과 행위 선언, 객체의 설계도 혹은 틀
객체:클래스의 틀로 찍어낸 실체  
(ex 클래스:소나타 자동차, 객체: 출고된 실제 소나타 100대)

클래스
  맴버: 클래스 구성 요소
  클래스에 대한 public 접근 지정: 다른 모든 클래스에서 클래스 사용허락

생성자 이름은 클래스 이름과 동일 
생성자는 여러 개 작성 가능

this: 객체 자신에 대한 레퍼런스 

가비지: 가리키는 레퍼런스가 없는것
가비지 컬렉션: 자바 가상 기게가 가비지 자동회수

객체 생성과 non-staic맴버의 생성: non-staic 맴버는 객체가 생성될 때, 객체마다 생긴다


## 3월 29일 강의
내용정리

System.in : 키보드와 연결된 자바의 표준 입력 스트림 직접사용하면 숫자를 변환하는데 어려움이 있음

Scanner : 읽은 바이트를 문자,정수, 실수,불린, 문자열 등 다양한 타입으로 변환 하여 리턴(입력되는 키 값을 공백으로 구분되는 토큰 단위로 읽음/공백 문자:'\t','\f','''')

연산
증감 ++  --  산술 +  -  *  /  %   비교  <  >  >=  <=  ==  !=

조건문?참:거짓
int foo=100;
int bar=50;
int big;

foo>bar?big=foo:big=bar;

비트:byte x =10;

비트연산자
a&b  and연산  두 비트 모두 1이면1 그렇지 않으면0
a|b  or연산   두 비트 모두 0이면0 그렇지 않으면1
a^b  xor연산  두 비트가 다르면1,같으면0
~a   not연산  1을 0으로 , 0을1로 변환



## 3월 22일 강의
내용정리

저급언어
 기계어:진수로 이루어진 언어 기계만 이해 가능
 어셈블리어: 기게어 명령 add,sub,mob등 
고급언어:사람이 이해하기 쉽고 복잡한 작업을 가능하게 하는 언어 ex.c언어

소스:프로그래밍 언어로 복잡한 택스트 파일
컴파일:소스파일을 컴퓨터가 이해할수 있는기계언어로 만드는 과정

Wora를 가능하게 하는 자바의 특징
 바이트 코드:자바 소스를 컴파일한 목적 코드 
 jvm:자바 바이트 코드를 실행하는 자바 가상 기계(소프트웨어) .class를 실행가능

응용프로그램 실행
main()메소드를 가진 클래스의 main()에서 실행(메인,자바에서는 메소드)

jdk:자바 응용 개발 환경(개발 할경우 쓴다)
jre:자바 실행 환경(파일을 실행할때 쓴다)

자바 api:jdk에 포함된 라이브러러리
자바 패키지:서로 관련된 클래스들을 분류하여 묶어 놓음 system.out.println(시스템->아웃->프린트)

class/ main/ print

서브릿:웹서버에 실행되는 자바 프로그램
안드로이드:옛날에 자바로 개발했음 

자바의 특징
 플랫폼의 독립성
 객체지향 언어
   -캡슐화,상속,다향성 지원
 클래스로 캡슐화
   -클래스 안에서 클래스 작성 가능
 소스와 클래스 파일
   -하나의 소스파일에 여러 클래스 가능
 실행코드 배포 
 패키지
 멀티스레드
   -여러스레드의 동시 수행 환경 지원
 가비지 컬렉션
   -자바 언어는 메모리 할당 가능은 있어도 메모리 변화 기능 없음
 실시간 응용프로그램에 부적합
 자바 프로그램은 안전
 프로그램 작성 쉬움 
 실행 속도 개선을 위한 jit컴파일러 사용

식별자:클래스, 변수, 상수, 메소드등의 붙이는 이름

변수:프로그램 실행중에 값을 임시저장하기 위한 공간
변수 선언:데이터 타입에서 정한 크기의 
리터럴:프로그램에서 직접 표현한 값
상수:변수처럼 바꿀수 없다


## 3월 15일 강의
내용정리

git hub 로그인방법
 git config (--global)vser.name"유저 이름"
 git config (--global)vser.email"유저 이메일"
등록확인
 git config vser.name